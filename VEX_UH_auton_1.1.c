#pragma config(Sensor, in1,    front,          sensorReflection)
#pragma config(Sensor, in2,    middle,         sensorReflection)
#pragma config(Sensor, in3,    centerback,     sensorReflection)
#pragma config(Sensor, in4,    leftback,       sensorReflection)
#pragma config(Sensor, in5,    righback,       sensorReflection)
#pragma config(Sensor, dgtl1,  left,           sensorRotation)
#pragma config(Sensor, dgtl2,  right,          sensorRotation)
#pragma config(Motor,  port1,           left1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           left2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           left3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           right1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           right2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           right3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           claw1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw2,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int turndist; //turn distance for 90 degrees

task main()
{

	//open claw
	motor[claw1]=motor[claw1]= 100;
	wait1Msec(200);
	motor[claw1]=motor[claw1]=0;

	//drive forward until line
	if(SensorValue[middle]<100){
	motor[left1]=motor[left2]=motor[left3]= 127;
	motor[right1]=motor[right2]=motor[right3]= 127;
	}else{
	motor[left1]=motor[left2]=motor[left3]= 0;
	motor[right1]=motor[right2]=motor[right3]= 0;
	}

	//zero encoders
	nMotorEncoder(left)=nMotorEncoder(right)=0;

	//turn until front and centerback light sensors are aligned
	if(SensorValue[centerback] && SensorValue[front] < 100){
	motor[left1]=motor[left2]=motor[left3]= -100;
	motor[right1]=motor[right2]=motor[right3]= 100;
	}else{
	motor[left1]=motor[left2]=motor[left3]= 0;
	motor[right1]=motor[right2]=motor[right3]= 0;
	}

	turndist = (nMotorEncoder(left)+nMotorEncoder(right))/2;

	//drive towards cube
	motor[left1]=motor[left2]=motor[left3]= 127;
	motor[right1]=motor[right2]=motor[right3]= 127;
	wait1Msec(200);
	motor[left1]=motor[left2]=motor[left3]= 0;
	motor[right1]=motor[right2]=motor[right3]= 0;

	//close claw
	motor[claw1]=motor[claw1]= -100;
	wait1Msec(200);
	motor[claw1]=motor[claw1]=0;

	//turn 90 degrees so rear faces wall
	while (nMotorEncoder[left] < turndist)
	{
 	motor[left1]=motor[left2]=motor[left3]= -100;
	motor[right1]=motor[right2]=motor[right3]= 100;
	}
	motor[left1]=motor[left2]=motor[left3]= 0;
	motor[right1]=motor[right2]=motor[right3]= 0;


}
