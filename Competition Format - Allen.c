#pragma config(Sensor, in1,    clawLPot,       sensorPotentiometer)
#pragma config(Sensor, in2,    clawRPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    front,          sensorLineFollower)
#pragma config(Sensor, in5,    middle,         sensorLineFollower)
#pragma config(Sensor, in6,    leftback,       sensorLineFollower)
#pragma config(Sensor, in7,    centerback,     sensorLineFollower)
#pragma config(Sensor, in8,    rightback,      sensorLineFollower)
#pragma config(Sensor, dgtl9,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encoderL,       sensorQuadEncoder)
#pragma config(Motor,  port1,           clawR,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift4,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           baseR1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           baseR2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           baseL1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           baseL2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawL,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//Predeclarations
void blockAuton();

/* Variables */
//Claw variables
int ClawLCalibrate = 97 - 90; //97 - calibrated value. difference from full closed value: (touching motor)
int ClawRCalibrate = 40; //4060 - calibrated value. difference form full closed value: + means bigger number
int ClawState = 9; 						// 0 - open, 1 - semi-closed, 2 - closed
int CloseLAngle = 820+ClawLCalibrate; 				//the angle the claw is closed
int CloseRAngle = 3100+ClawRCalibrate; 				//the angle the claw is closed
int ClawLSemicloseAngle = 1900+ClawLCalibrate;//the angle the claw stays at in intake pos
int ClawRSemicloseAngle = 2120+ClawRCalibrate;
int ClawLOpen = 1900+ClawLCalibrate; 					//Angle claw is fully open
int ClawROpen = 1600+ClawRCalibrate;
int ClawLFullOpen = 1900+ClawLCalibrate; 			//If we get Stuck, we can fully open the claw
int ClawRFullOpen = 1600+ClawRCalibrate;
int CustomAngleL = 0+ClawLCalibrate; 					//If we want different/custom angles
int CustomAngleR = 0+ClawRCalibrate;

//PID stalls
int ClosePower = 70;//127 				// the test value for stall detect
int ClawStallPower = 70;//60 			//power after stall
int ClawStallTime = 1500;//1000 			//if the claw is not moving for this time, go to low power
float ClawP = .4;//.1? 	//P value for claw PID
float ClawD = .001;//.001 	// D value for PID
float ClawI = .005; //.015
float ClawFineP = 1;//.2 //when error gets close to 0, this takes over
int 	ClawFinePLimit = 10; //15 // this is the max power Fine motor can provide
float ClawFineOffset = (ClawFineP==0?0:ClawFinePLimit-(ClawFinePLimit/ClawFineP*ClawP));
int 	PILimit = 65;//60 // the limit of the total power P+I can provide

//Arm Variables##############################################################
int ArmState = 9; 		// disabled
int ArmCalibrate = 0; //2810 is zero position
float ArmP = .12;		//.1? 	//P value for claw PID
float ArmD = .000;	//.006 	// D value for PID
float ArmI = .0025; 	//.0025
float ArmFineP = .1;	//.08 //when error gets close to 0, this takes over
int ArmFinePLimit = 75; //12 // this is the max power Fine motor can provide
float ArmFineOffset = (ArmFineP==0?0:ArmFinePLimit-(ArmFinePLimit/ArmFineP*ArmP));
int ArmPILimit = 45;	//60 // the limit of the total power P+I can provide
int ArmStallPower = 50; //60
int ArmStallDetect = 50;//60
int ArmStallTime = 1000;//1000 in milliseconds
int FireDetectAngle = 2800+ArmCalibrate; //2880 the angle it will consider the
int FireExpireTime = 1500; //1500 if it is firing for longer than this amount of time, firing stops
int FireOverdriveTime = 20; // 60number of milliseconds it will keep driving arm after it reached fire angle
bool ArmFired = false;
// arm angles
int CustomAngle 	= 2770; 							//Custom arm angle
int ArmDownAngle	= 960+ArmCalibrate;		//intake angle
int ArmPrimeAngle = 1400+ArmCalibrate; 	//1070 just above the ground
int ArmHighAngle 	= 1690+ArmCalibrate;	//just a fun angle for w/e
int ArmTopAngle 	= 2940+ArmCalibrate;	//after firing it will go here

bool hasObject = false;

//functions
void pre_auton(){bStopTasksBetweenModes = true;}

void SetBase(int powerL, int powerR)
{
	motor[baseL1]=powerL;
	motor[baseL2]=powerL;
	motor[baseR1]=powerR;
	motor[baseR2]=powerR;
	return;
}

void SetArm(int power)
{
	motor[lift1]=power;
	motor[lift2]=power;
	motor[lift3]=power;
	motor[lift4]=power;
}

void SetClawL(int powerL) {motor[clawL] = powerL;}
void SetClawR(int powerR) {motor[clawR] = powerR;}

//tasks
task clawTask() //this just manages the PID on the robot
{
	int clawLTarget = 0;
	int clawRTarget = 0;
	int clawPowerL = 0;
	int clawPowerR = 0;
	int potentiometerL = 0;
	int potentiometerR = 0;
	int currentTime = time1[T1];
	int lastTime = currentTime;
	int dTime = 0;
	int errorL = 0;
	int errorR = 0;
	int lastErrorL = 0;
	int lastErrorR = 0;
	int dErrorL = 0;
	int dErrorR = 0;
	int dErrorLLog[] = {0,0,0,0};
	int dErrorRLog[] = {0,0,0,0};
	int accErrorL = 0;//accumulated error for Integral
	int accErrorR = 0;
	bool enablePID = false;

	//stall timing
	bool stalledL = false;
	bool stalledR = false;
	int stallTimeL = 0;
	int stallTimeR = 0;

	while (true)
	{
		//updates values
		potentiometerL = SensorValue[clawLPot];
		potentiometerR = SensorValue[clawRPot];
		currentTime = time1[T1];
		dTime = currentTime - lastTime;
		errorL = -clawLTarget + potentiometerL; //Updating errors (difference between target and true pos, negative is more open)
		errorR = +clawRTarget - potentiometerR;
		//first run in this state? do this!
		if (ClawState != 0)
		{
			switch (ClawState) //sets targets
			{
			case 1:
				clawLTarget = CustomAngleL;
				clawRTarget = CustomAngleR;
				enablePID = true;
				break;
			case 2:
				clawLTarget = CloseLAngle;
				clawRTarget = CloseRAngle;
				enablePID = true;
				break;
			case 3:
				clawLTarget = ClawLSemicloseAngle;
				clawRTarget = ClawRSemicloseAngle;
				enablePID = true;
				break;
			case 4:
				clawLTarget = ClawLOpen;
				clawRTarget = ClawROpen;
				enablePID = true;
				break;
			case 5:
				clawLTarget = ClawLFullOpen;
				clawRTarget = ClawRFullOpen;
				enablePID = true;
				break;
			default:
				enablePID = false;
				break;
			}
			ClawState = 0;
			lastErrorL = errorL;
			lastErrorR = errorR;
			accErrorL = accErrorR = 0;//setting integral to 0
			stalledL = false;
			stalledR = false;
			stallTimeL = 0;
			stallTimeR = 0;
		}
		// dError calculation
		dErrorL = (errorL - lastErrorL)*(dTime>0?1000/dTime:0); //the speed over the last time period in pot ticks per sec
		dErrorR = (errorR - lastErrorR)*(dTime>0?1000/dTime:0);

		//Integral addition
		if ((abs(accErrorL)>abs(accErrorL+errorL))) {accErrorL+= errorL;}//if acc error will be reduced
		else if ((abs(errorL*ClawP + accErrorL*ClawI)+ClawFineOffset)<=PILimit)//if the motor output is less than the cap, you can accumulate)
		{
			accErrorL+=errorL;
		}

		if ((abs(accErrorR)>abs(accErrorR+errorR))) {accErrorR+= errorR;}//if acc error will be reduced
		else if ((abs(errorR*ClawP + accErrorR*ClawI)+ClawFineOffset)<=PILimit)//if the motor output is less than the cap, you can accumulate)
		{
			accErrorR+=errorR;
		}
		clawPowerL = (abs(errorL*ClawFineP)<ClawFinePLimit? errorL*ClawFineP:(errorL*ClawP+(errorL>0?ClawFineOffset:-ClawFineOffset))) + dErrorL*ClawD + accErrorL*ClawI; //claw power according to the PIDs
		clawPowerR = (abs(errorR*ClawFineP)<ClawFinePLimit? errorR*ClawFineP:(errorR*ClawP+(errorR>0?ClawFineOffset:-ClawFineOffset))) + dErrorR*ClawD + accErrorR*ClawI; // attempt to filter stuff

		//Stall stuff------------------------------
		if(abs(clawPowerL)> ClosePower)//checking whether motors are stalling
		{
			stallTimeL+=dTime;
			if(stallTimeL>ClawStallTime) {stalledL = true;}//updates stallL state
		}
		else
		{
			stalledL = false;
			stallTimeL = 0;
		}

		if(abs(clawPowerR) > ClosePower) //checking whether motors are stalling
		{
			stallTimeR+=dTime;
			if(stallTimeR>ClawStallTime) {stalledR = true;}//updates stalleR state
		}
		else
		{
			stalledR = false;
			stallTimeR = 0;
		}

		//Setting motor power ------------------------------------------------
		if(!enablePID){SetClawL(0);}//If PID disabled
		else if(stalledL){SetClawL(clawPowerL>0?ClawStallPower:-ClawStallPower);}//If stalled, it will run at max stall power
		else{SetClawL(clawPowerL);}// Setting the powers to the motors.

		if(!enablePID){SetClawR(0);}//If PID disabled
		else if(stalledR){SetClawR(clawPowerR>0?ClawStallPower:-ClawStallPower);}//If stalled, it will run at max stall power
		else{SetClawR(clawPowerR);}// Setting the powers to the motors.

		lastErrorL = errorL;
		lastErrorR = errorR;
		lastTime = time1[T1];
		wait1Msec(20);
	}
}
task armTask()//#################################################################################
{
	//declarations
	int currentTime = 0;
	int lastTime = 0;
	int dTime = 0;
	int error = 0;
	int lastError = 0;
	int dError = 0;
	int accError = 0;//accumulated error for Integral
	int armTarget = 0;
	int armPower = 0;
	int armPotentiometer = 0;
	int stallTime = 0;
	int armState = 0; //this is the local state (if this isn't there, there is a 1 in 40 chance that the command won't execute)

	//firing
	int fireTargetTime = 0; // for timeout
	bool fire = false; // tells the code that the fire macro has been called
	bool stalled = false;
	bool enablePID = false;

	//average Derrors
	int logPos = 0;
	int dErrorAvg = 0;
	int dErrorLog[] = {0,0,0,0,0,0,0,0,0,0};

	while (true)
	{
		//Updates
		armState = ArmState;
		if (armState != 0) // 0 is the "State is up to date - state. Once the variables are updated in the code, state will go back to 1
		{
			switch (armState) //sets targets
			{
			case 1: //custom angle
				armTarget = CustomAngle;
				fire = false;
				enablePID = true;
				break;
			case 2:
				armTarget = ArmDownAngle;
				fire = false;
				enablePID = true;
				break;
			case 3:
				armTarget = ArmPrimeAngle;
				fire = false;
				enablePID = true;
				break;
			case 4:
				armTarget = ArmHighAngle;
				fire = false;
				enablePID = true;
				break;
			case 5:
				armTarget = ArmTopAngle;
				enablePID = true;
				fire = true;
				break;
			default:
				enablePID = false;
				fire = false;
				break;
			}
			stallTime = 0; //time before stall is true
			stalled = false; //limits motor power
			dErrorAvg = 0;
			dErrorLog[0]=dErrorLog[1]=dErrorLog[2]=dErrorLog[3]=dErrorLog[4]=dErrorLog[5]=dErrorLog[6]=dErrorLog[7]=dErrorLog[8]=dErrorLog[9]= 0;
			lastError = armTarget - SensorValue[armPot];
			fireTargetTime = 0;
			ArmState = 0;	// Setting arm state to updated
		}
		currentTime = time1[T1];
		dTime = currentTime - lastTime;
		armPotentiometer = SensorValue[armPot];
		lastTime = currentTime;
		error = armTarget - armPotentiometer;
		dError = (error - lastError)*(dTime>0?1000/dTime:0);

		//PID addition part
		if ((abs(accError)>abs(accError+error))) {accError+= error;}//if acc error will be reduced
		else if ((abs(error*ArmP + accError*ArmI)+ArmFineOffset)<=ArmPILimit){accError+=error;}//if the motor output is less than the cap, you can accumulate

		armPower = (abs(error*ArmFineP)<ArmFinePLimit? error*ArmFineP:(error*ArmP+(error>0?ArmFineOffset:-ArmFineOffset))) + dErrorAvg*ArmD + accError*ArmI; //arm power according to the PIDs

		//Stall Check
		if(abs(armPower)> ArmStallDetect)//checking whether motors are stalling
		{
			stallTime+=dTime;
			if(stallTime>ArmStallTime) {stalled = true;}//updates stallL state
		}
		else
		{
			stalled = false;
			stallTime = 0;
		}
		//Fire stuffs
		if (fire && fireTargetTime == 0){fireTargetTime = currentTime+FireExpireTime;}
		else if (fire && armPotentiometer >= FireDetectAngle && fireTargetTime > (currentTime+FireOverdriveTime)){fireTargetTime = currentTime+FireOverdriveTime;}

		//Setting motor powers
		if (!enablePID){SetArm(0);}
		else if(fire){SetArm(127);}
		else if(stalled){SetArm(armPower>0?ArmStallPower:-ArmStallPower);}//If stalled, it will run at max stall power
		else {SetArm(armPower);}// Setting the power to the motors.

		if (fire && currentTime>fireTargetTime)
		{
			fire = false;
			ArmFired = true;
			if (ArmState == 0){ArmState = 4;}//the state at which the arm will go upright
		}
		dErrorAvg += (-dErrorLog[logPos]/10);
		dErrorLog[logPos] = dError;
		dErrorAvg += (dError/10);
		++logPos;
		if (logPos>9){logPos = 0;}
		lastError = error;
		lastTime = currentTime;
		wait1Msec(20);
	}
}
task driveManager()
{
	while (true)
	{
		if (vexRT[Btn6U]){ClawState = 2;}
		else if (vexRT[Btn6D]){ClawState =3;}
		else if (vexRT[Btn8R]){ClawState = 9;}

		if (vexRT[Btn5U]) {ArmState= 3;}// arm testing
		else if (vexRT[Btn5D]){ArmState = 2;}
		else if (vexRT[Btn7L]){ArmState = 9;}
		else if (vexRT[Btn7D]){ArmState = 5;

		//this will manage the inputs from the driver and decide what state to put everything on the robot
		wait1Msec(20);
	}
}

/*----------------To do list------------------*/
/*calculate distance to fence so we can go back the exact same distance
fix the drive distance functionn
fix the parameters in the drive distance function*/







//

task autonomous(){
	/* Initalize Controllers */
	clearDebugStream();
	datalogClear();
	clearTimer(T1);
	startTask(clawTask);
	wait1Msec(5);
	startTask(armTask);

	//blockAuton();

	/* Open Claw to Start */
	ClawState = 5;
	while(!((SensorValue[clawLPot] < (ClawLFullOpen + 100) && SensorValue[clawLPot] > (ClawLFullOpen - 100)) &&
		(SensorValue[clawRPot] < (ClawRFullOpen + 100) && SensorValue[clawRPot] > (ClawRFullOpen - 100)))){} // Wait until state


	//wait1Msec(200);


	////disable PID
	//wait1Msec(300)
	//SensorValue[encoderL] = SensorValue[encoderR] = 0;

	////move foward
	//while(sensorvalue[encoderR] < 400)///////{
	//	SetBase(40,40);

	// }

	// wait1Msec(300);

	// SensorValue[encoderL] = SensorValue[encoderR] = 0;
	////turns backward
	//while(sensorvalue[encoderR] < 100)/////////{
	//	SetBase(-40,40);

	// }

	// wait1Msec(300);
	// //moving towards fence
	// SensorValue[encoderL] = SensorValue[encoderR] = 0;
	// while(sensorvalue[encoderR] < 100)///////{
	//	SetBase(-100,-100);

	// }
	// wait1Msec(300);

	// // stop base
	// SetBase(0,0);




	//SensorValue[encoderL] = SensorValue[encoderR] = 0;
	//while(SensorValue[encoderL] > -720)
	//{
	//	SetBase(-30,0);
	//}

	//SetBase(0,0);		// I set motors to zero after it reaches center of the field

	//wait10Msec(10);

	//SensorValue[encoderL] = SensorValue[encoderR] = 0;
	//while(SensorValue[encoderR] < 120)
	//{
	//	SetBase(60,60);
	//	}

	//wait10Msec(30);


	////robot closes claw and picks up cubes
	//ClawState = 2;
	//while(!((SensorValue[clawLPot] < (CloseLAngle + 100) && SensorValue[clawLPot] > (CloseLAngle - 100)) &&
	//	(SensorValue[clawRPot] < (CloseRAngle + 100) && SensorValue[clawRPot] > (CloseRAngle - 100)))){} // Wait until state


	////robot lifts up arm
	//ArmState = 4;
	//while(!(SensorValue[armPot] < (ArmHighAngle + 100) && SensorValue[armPot] > (ArmHighAngle - 100))){} // Wait until state

	//SensorValue[encoderL] = SensorValue[encoderR] = 0;
	//while(SensorValue[encoderL] > -100) {
	//	SetBase(-30,0);
	//}

	//SensorValue[encoderL] = SensorValue[encoderR] = 0;
	//while(SensorValue[encoderL] > -70) {
	//	SetBase(-30,-30);
	//}
	//SetBase(0,0)

	//wait10Msec(500);

	////robot turn 90 degrees when it gets to line
	//while(SensorValue(front) > 400 &&  SensorValue(centerback) > 400 ){
	//	SetBase(-40,40);
	//	while(SensorValue(front) < 400 && SensorValue(centerback) > 400){
	//		SetBase(-30,30);
	//	}
	//	while(SensorValue(front) > 400 && SensorValue(centerback) < 400){
	//		SetBase(30,-30);
	//	}
	//}

	//SetBase(0,0);

	//wait1Msec(200);



	////robot moves a distance of half the field


	//driveDistance(600,100);  //sets drive distance to 61 inches and power to 80
	//wait1Msec(200);

	////robot closes claw and picks up cubes
	//ClawState = 2;
	//while(!((SensorValue[clawLPot] < (CloseLAngle + 100) && SensorValue[clawLPot] > (CloseLAngle - 100)) &&
	//	(SensorValue[clawRPot] < (CloseRAngle + 100) && SensorValue[clawRPot] > (CloseRAngle - 100)))){} // Wait until state


	////robot lifts up arm
	//ArmState = 4;
	//while(!(SensorValue[armPot] < (ArmHighAngle + 100) && SensorValue[armPot] > (ArmHighAngle - 100))){} // Wait until state


	//SensorValue(encoderR) = SensorValue(encoderL)= 0;

	////robot does 90 degree turn
	//while(SensorValue(encoderR) > 1000)
	//{
	//	SetBase(-40,40);
	//}
	//SetBase(0,0);

	////robot moves backwards till it sees the line
	////Set code to stop robot from bumbing into the fence if it doesnt read the sensors
	//while(SensorValue(rightback) > 400 /*adjust value*/&& SensorValue(leftback) > 400/*adjust value*/){
	//	SetBase(-40,-40);
	//	if(SensorValue(rightback) < 400/*adjust value*/ && SensorValue(leftback) > 400/*adjust value*/)
	//	{  while(SensorValue(leftback) > 400){
	//			SetBase(-30,0);
	//		}
	//	}
	//	if(SensorValue(rightback) > 400/*adjust value*/ && SensorValue(leftback) < 400/*adjust value*/)
	//	{  while(SensorValue(rightback) > 400){
	//			SetBase(0,-30);
	//		}
	//	}
	//}

	//SetBase(0,0);    //zeroing motors
	//wait1Msec(100);

	////robot moves cloesr to the fence
	//while(SensorValue(middle) > 400/*adjust value*/)
	//{
	//	SetBase(-35,-35);
	//}
	//SetBase(0,0);

	////fire cube
	//ArmState = 5;  //sets arm to fire
	//while(!(SensorValue[armPot] < (ArmTopAngle + 100) && SensorValue[armPot] > (ArmTopAngle - 100))){} // Wait until state

	////Releases Cube
	//ClawState = 5;
	//while(!((SensorValue[clawLPot] < (ClawLFullOpen + 100) && SensorValue[clawLPot] > (ClawLFullOpen - 100)) &&
	//	(SensorValue[clawRPot] < (ClawRFullOpen + 100) && SensorValue[clawRPot] > (ClawRFullOpen - 100)))){} // Wait until state

	////brings lift back down
	//ArmState = 2;  //atate brings arm down
	//while(!(SensorValue[armPot] < (ArmDownAngle + 100) && SensorValue[armPot] > (ArmDownAngle - 100))){} // Wait until state

	////it should back up a little bit
	//int targetL;   // find wht target value we should use
	//while(SensorValue[encoderL] <  targetL)
	//{
	//	SetBase(50,50);

	//}

	////drives back to pik stars
	//while(SensorValue[centerback] > 400)
	//{
	//	SetBase(50,50);
	//}

	//wait1Msec(100);

	////claw closing
	//ClawState = 2;
	//while(!((SensorValue[clawLPot] < (CloseLAngle + 100) && SensorValue[clawLPot] > (CloseLAngle - 100)) &&
	//	(SensorValue[clawRPot] < (CloseRAngle + 100) && SensorValue[clawRPot] > (CloseRAngle - 100)))){} // Wait until state
	////arm raising
	//ArmState = 4;
	//while(!(SensorValue[armPot] < (ArmHighAngle + 100) && SensorValue[armPot] > (ArmHighAngle - 100))){} // Wait until state

	////drive up to line again
	//while(SensorValue(rightback) > 400 /*adjust value*/&& SensorValue(leftback) > 400/*adjust value*/){
	//	SetBase(-40,-40);

	//	if(SensorValue(rightback) < 400/*adjust value*/ && SensorValue(leftback) > 400/*adjust value*/)
	//	{  while(SensorValue(leftback) > 400){
	//			SetBase(-30,0);
	//		}
	//	}
	//	if(SensorValue(rightback) > 400/*adjust value*/ && SensorValue(leftback) < 400/*adjust value*/)
	//	{  while(SensorValue(rightback) > 400){
	//			SetBase(0,-30);
	//		}
	//	}
	//}

	//while(SensorValue(leftback) > 400/*adjust value*/)
	//{
	//	SetBase(-35,-35);
	//}
	//SetBase(0,0);

	////firing stars
	//ArmState = 5;
	//while(!(SensorValue[armPot] < (ArmTopAngle + 100) && SensorValue[armPot] > (ArmTopAngle - 100))){} // Wait until state

	//// Releases Stars
	//ClawState = 5;
	//while(!((SensorValue[clawLPot] < (ClawLFullOpen + 100) && SensorValue[clawLPot] > (ClawLFullOpen - 100)) &&
	//	(SensorValue[clawRPot] < (ClawRFullOpen + 100) && SensorValue[clawRPot] > (ClawRFullOpen - 100)))){} // Wait until state

	////Lowers Arm
	//ArmState = 2;
	//while(!(SensorValue[armPot] < (ArmDownAngle + 100) && SensorValue[armPot] > (ArmDownAngle - 100))){}//brings claw down

	////for now end autonomous;
}

task usercontrol()
{
	clearDebugStream();
	datalogClear();
	clearTimer(T1);
	startTask(clawTask);
	startTask(driveManager);
	wait1Msec(5);
	startTask(armTask);
	int leftPower = 0;
	int rightPower = 0;
	while (true)
	{
		//	if(vexRT(Btn8D))
		//	{
		//		autonomous1();
		//}
		leftPower 	= vexRT[Ch3] + vexRT[Ch1];
		rightPower 	= vexRT[Ch3] - vexRT[Ch1];
		SetBase(leftPower,rightPower);
		wait1Msec(20);
	}
}

void blockAuton() {
	/* Open Claw to Start */
	ClawState = 5;
	while(!((SensorValue[clawLPot] < (ClawLFullOpen + 100) && SensorValue[clawLPot] > (ClawLFullOpen - 100)) &&
		(SensorValue[clawRPot] < (ClawRFullOpen + 100) && SensorValue[clawRPot] > (ClawRFullOpen - 100)))){} // Wait until state

	/* Drive to Position */
	ArmState = 1;  // raise arms to drive
	while(!(SensorValue[armPot] < (CustomAngle + 100) && SensorValue[armPot] > (CustomAngle - 100))){} // Wait until state

	ArmState = 9; // Disable Controller

	wait1Msec(100);
	SensorValue[encoderL] = SensorValue[encoderR] = 0;

	//move foward
	int firstdrive = 500;
	int encR = 600;

	while(((SensorValue[encoderR] + SensorValue[encoderL]) / 2 ) < firstdrive){//move past cube
		SetBase(70,70);
	}

	wait1Msec(200);
	SensorValue[encoderL] = SensorValue[encoderR] = 0;

	while(SensorValue[encoderR] < 470){ //turn 90 Degrees
		SetBase(-40,40);
	}

	SensorValue[encoderL] = SensorValue[encoderR] = 0;
	while(((SensorValue[encoderR] + SensorValue[encoderL]) * 0.5) < encR){ //move to middle
		SetBase(100,100);
	}

	SensorValue[encoderL] = SensorValue[encoderR] = 0;

	while(SensorValue[encoderR] < 470){ //turn 90 Degrees
		SetBase(-40, 40);
	}

	SetBase(-40,-40); //drive up to wall forever

	wait1Msec(1000);

	/* Blocking Position */
	ArmState = 1;  //raise arm completely up
	while(!(SensorValue[armPot] < (CustomAngle + 100) && SensorValue[armPot] > (CustomAngle - 100))){}
}
