#pragma config(Sensor, in1,    clawLPot,       sensorPotentiometer)
#pragma config(Sensor, in2,    clawRPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    front,          sensorLineFollower)
#pragma config(Sensor, in5,    middle,         sensorLineFollower)
#pragma config(Sensor, in6,    leftback,       sensorLineFollower)
#pragma config(Sensor, in7,    centerback,     sensorLineFollower)
#pragma config(Sensor, in8,    rightback,      sensorLineFollower)
#pragma config(Sensor, dgtl9,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encoderL,       sensorQuadEncoder)
/*** Diff
#pragma config(Sensor, in5,    middle,         sensorReflection)
#pragma config(Sensor, in7,    centerback,     sensorReflection)
#pragma config(Sensor, in6,    leftback,       sensorReflection)
#pragma config(Sensor, in8,    righback,       sensorReflection)
#pragma config(Sensor, in4,    front,          sensorReflection)
***/
#pragma config(Motor,  port1,           clawR,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift4,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           baseR1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           baseR2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           baseL1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           baseL2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawL,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// Prototypes
task clawTask();
void SetBase(int powerL, int powerR);
void SetArm(int power);

// Pot calibration
// C: Did anything used to go here

// Variables
// Claw variables
int ClawLCalibrate = 97 - 90; //97 - calibrated value. difference from full closed value: (touching motor)
int ClawRCalibrate = 40; //4060 - calibrated value. difference form full closed value: + means bigger number
int ClawState = 9;                         // 0 - open, 1 - semi-closed, 2 - closed
int CloseLAngle = 820+ClawLCalibrate;                 // The angle the claw is closed
int CloseRAngle = 3100+ClawRCalibrate;                 // The angle the claw is closed
int ClawLSemicloseAngle = 1900+ClawLCalibrate;// The angle the claw stays at in intake pos
int ClawRSemicloseAngle = 2120+ClawRCalibrate;
int ClawLOpen = 1900+ClawLCalibrate;                     // Angle claw is fully open
int ClawROpen = 1600+ClawRCalibrate;
int ClawLFullOpen = 1900+ClawLCalibrate;             // If we get Stuck, we can fully open the claw
int ClawRFullOpen = 1600+ClawRCalibrate;
int CustomAngleL = 0+ClawLCalibrate; // If we want different/custom angles
int CustomAngleR = 0+ClawRCalibrate;

// PID/stalls
int ClosePower = 70;//127                 // The test value for stall detect
int ClawStallPower = 70;//60             // Power after stall
int ClawStallTime = 1500;//1000             // If the claw is not moving for this time, go to low power
float ClawP = .4; //.1?     // P value for claw PID
/*** Diff
float ClawP = .2; //.1?     // P value for claw PID
***/
float ClawD = .001; //.001     // D value for PID
float ClawI = .005; //.015
float ClawFineP = 1; //.2 // When error gets close to 0, this takes over
/*** Diff
float ClawFineP = .4;//.2 // When error gets close to 0, this takes over
***/
int     ClawFinePLimit = 10; //15 // This is the max power Fine motor can provide
float ClawFineOffset = (ClawFineP==0?0:ClawFinePLimit-(ClawFinePLimit/ClawFineP*ClawP));
int     PILimit = 65;//60 // The limit of the total power P+I can provide

//Arm Variables##############################################################
int ArmState = 9;         // Disabled
int ArmCalibrate = 0;   //2810 is zero position
float ArmP = .12;       //.1?     // P value for claw PID
float ArmD = .000;      //.006    // D value for PID
/*** Diff
float ArmP = .8;        //.1?     // P value for claw PID
float ArmD = .002;      //.006    // D value for PID
***/
float ArmI = .0025;     //.0025
float ArmFineP = .1;    //.08     // When error gets close to 0, this takes over
int ArmFinePLimit = 75; //12      // This is the max power Fine motor can provide
/*** Diff
float ArmFineP = .2;    //.08     // When error gets close to 0, this takes over
int ArmFinePLimit = 8;  //12      // This is the max power Fine motor can provide
***/
float ArmFineOffset = (ArmFineP==0?0:ArmFinePLimit-(ArmFinePLimit/ArmFineP*ArmP));
int ArmPILimit = 45;    //60 // The limit of the total power P+I can provide
int ArmStallPower = 50; //60
int ArmStallDetect = 50;//60
int ArmStallTime = 1000;//1000 in milliseconds
int FireDetectAngle = 2800+ArmCalibrate; //2880 the angle it will consider the
int FireExpireTime = 1500; //1500 if it is firing for longer than this amount of time, firing stops
int FireOverdriveTime = 20; //60 number of milliseconds it will keep driving arm after it reached fire angle
bool ArmFired = false;
// Arm angles
int CustomAngle     = 2770; // Custom arm angle
int ArmDownAngle    = 960+ArmCalibrate; // Intake angle
int ArmPrimeAngle = 1400+ArmCalibrate; //1070 just above the ground
int ArmHighAngle     = 1690+ArmCalibrate;// Just a fun angle for w/e
int ArmTopAngle     = 2940+ArmCalibrate;// After firing it will go here

// Functions

// Function to make code go a certain distance
void driveDistance(int target, int power)
{
    // Setting sensors to zero
    SensorValue[encoderR] = 0;
    SensorValue[encoderL] = 0;


    // The right encoder will be used to measure distance

    int senL =  SensorValue[encoderL];
    int senR =  SensorValue[encoderR];
    int sensor = SensorValue[encoderR];
    while(sensor < target)
    {
        motor[baseL1]=power;
        motor[baseL2]=power;
        motor[baseR1]=power;
        motor[baseR2]=power;

        if(senL > senR)
        {
            SensorValue[encoderR] = senL;
            sensor = senL;
        }
        if(senL < senR)
        {
            SensorValue[encoderL] = senR;
            sensor = senR;
        }
        if(senL == senR)
        {
            sensor = senR;
        }

    }
    motor[baseL1]=0;
    motor[baseL2]=0;
    motor[baseR1]=0;
    motor[baseR2]=0;
}

//C: What's the point of this function?
void pre_auton()
{
    bStopTasksBetweenModes = true;
}
void SetBase(int powerL, int powerR)
{
    motor[baseL1]=powerL;
    motor[baseL2]=powerL;
    motor[baseR1]=powerR;
    motor[baseR2]=powerR;
    return;
}
void SetArm(int power)
{
    motor[lift1]=power;
    motor[lift2]=power;
    motor[lift3]=power;
    motor[lift4]=power;
}
void SetClawL(int powerL)
{
    motor[clawL] = powerL;
}
void SetClawR(int powerR)
{
    motor[clawR] = powerR;
}

// Tasks
task clawTask() // This manages the PID on the robot
{
    int clawLTarget = 0;
    int clawRTarget = 0;
    int clawPowerL = 0;
    int clawPowerR = 0;
    int potentiometerL = 0;
    int potentiometerR = 0;
    int currentTime = time1[T1];
    int lastTime = currentTime;
    int dTime = 0;
    int errorL = 0;
    int errorR = 0;
    int lastErrorL = 0;
    int lastErrorR = 0;
    int dErrorL = 0;
    int dErrorR = 0;
    int dErrorLLog[] = {0,0,0,0};
    int dErrorRLog[] = {0,0,0,0};
    //int avgDErrorL = 0;
    //int avgDErrorR = 0;
    //int logPos = 0;
    int accErrorL = 0; // Accumulated error for Integral
    int accErrorR = 0;
    bool enablePID = false;

    // Stall timing
    bool stalledL = false;
    bool stalledR = false;
    int stallTimeL = 0;
    int stallTimeR = 0;

    while (true)
    {
        // Updates values
        potentiometerL = SensorValue[clawLPot];
        potentiometerR = SensorValue[clawRPot];
        currentTime = time1[T1];
        dTime = currentTime - lastTime;

        errorL = -clawLTarget + potentiometerL; // Updating errors (difference between target and true pos, negative is more open)
        errorR = +clawRTarget - potentiometerR;
        // If this is the first loop iteration, do this!
        if (ClawState != 0) // This really doesn't mean much. Only for the first state change where dError would be big otherwise
        {
            switch (ClawState) // Sets targets
            {
            case 1:
                clawLTarget = CustomAngleL;
                clawRTarget = CustomAngleR;
                enablePID = true;
                break;
            case 2:
                clawLTarget = CloseLAngle;
                clawRTarget = CloseRAngle;
                enablePID = true;
                break;
            case 3:
                clawLTarget = ClawLSemicloseAngle;
                clawRTarget = ClawRSemicloseAngle;
                enablePID = true;
                break;
            case 4:
                clawLTarget = ClawLOpen;
                clawRTarget = ClawROpen;
                enablePID = true;
                break;
            case 5:
                clawLTarget = ClawLFullOpen;
                clawRTarget = ClawRFullOpen;
                enablePID = true;
                break;
            default:
                enablePID = false;
                break;
            }
            ClawState = 0;
            lastErrorL = errorL;
            lastErrorR = errorR;
            accErrorL = accErrorR = 0;// Setting integral (I in PID) to 0
            stalledL = false;
            stalledR = false;
            stallTimeL = 0;
            stallTimeR = 0;
        }

        // dError calculation
        dErrorL = (errorL - lastErrorL)*(dTime>0?1000/dTime:0); // The speed over the last time period in pot ticks per sec
        dErrorR = (errorR - lastErrorR)*(dTime>0?1000/dTime:0);
        /*
        dErrorLLog[logPos] = dErrorL; // trying to filter bad values
        dErrorRLog[logPos] = dErrorR;
        avgDErrorL = dErrorLLog[0];
        avgDErrorR = dErrorRLog[0];
        for (int x = 1; x<(sizeof(dErrorLLog)/sizeof(dErrorLLog[0])); ++x)// finding the minimum dError
        {
            avgDErrorL += dErrorLLog[x]; //= (abs(avgDErrorL)<abs(dErrorLLog[x]))?avgDErrorL:dErrorLLog[x];    //min dErrorL value
            avgDErrorR += dErrorRLog[x]//= (abs(avgDErrorR)<abs(dErrorRLog[x]))?avgDErrorR:dErrorRLog[x];; //min R value
        }
        avgDErrorL = avgDErrorL/(sizeof(dErrorLLog)/sizeof(dErrorLLog[0]));
        avgDErrorR = avgDErrorR/(sizeof(dErrorLLog)/sizeof(dErrorLLog[0]));
        */

        //Integral addition
        if ( abs(accErrorL) > abs(accErrorL + errorL) ) // If acc error will be reduced
        {
            accErrorL+= errorL;
        }
        else if ( (abs((errorL * ClawP) + (accErrorL * ClawI)) + ClawFineOffset) <= PILimit ) // If the motor output is less than the cap, you can accumulate
        {
            accErrorL+=errorL;
        }
        if ( abs(accErrorR) > abs(accErrorR + errorR) ) // If acc error will be reduced
        {
            accErrorR+= errorR;
        }
        else if ( (abs((errorR * ClawP) + (accErrorR * ClawI)) + ClawFineOffset) <=PILimit) // If the motor output is less than the cap, you can accumulate
        {
            accErrorR+=errorR;
        }
        /*** Did I de-nest this correctly?
        clawPowerL = (abs(errorL*ClawFineP)<ClawFinePLimit? errorL*ClawFineP:(errorL*ClawP+(errorL>0?ClawFineOffset:-ClawFineOffset))) + dErrorL*ClawD + accErrorL*ClawI; //claw power according to the PIDs
        clawPowerR = (abs(errorR*ClawFineP)<ClawFinePLimit? errorR*ClawFineP:(errorR*ClawP+(errorR>0?ClawFineOffset:-ClawFineOffset))) + dErrorR*ClawD + accErrorR*ClawI; // attempt to filter stuff
        ***/
        if ( abs(errorL * ClawFineP) < ClawFinePLimit )
        {
            clawPowerL = errorL * ClawFineP
        }
        else if (errorL > 0)
        {
            clawPowerL = errorL * ClawP + ClawFineOffset
        }
        else
        {
            clawPowerL = erorrL * ClawP - ClawFineOffset
        }
        
        ClawPowerL += (dErrorL * ClawD) + (accErrorL * ClawI);

        if ( abs(errorR * ClawFineP) < ClawFinePLimit )
        {
            clawPowerR = errorR * ClawFineP
        }
        else if ( errorR > 0 )
        {
            clawPowerR = errorR * ClawP + ClawFineOffset
        }
        else
        {
            clawPowerR = errorR + ClawP - ClawFineOffset
        }

        clawPowerR += (dErrorR * ClawD) + (accErrorR * ClawI)

        /*-------------------Logging-------------------*/
        //writeDebugStreamLine("Claw Power L: %d\nClaw Power R: %d",clawPowerL,clawPowerR);
        //datalogDataGroupStart();
        //datalogAddValue(0,motor[clawL]);
        //datalogAddValue(1,motor[clawR]);
        //datalogAddValue(2,errorL);
        //datalogAddValue(3,errorR);
        //datalogDataGroupEnd();

        /*-------------------Stall stuff-------------------*/
        if(abs(clawPowerL)> ClosePower)//checking whether motors are stalling
        {
            stallTimeL+=dTime;
            if(stallTimeL>ClawStallTime) //updates stalleL state
            {
                stalledL = true;
            }
        }
        else
        {
            stalledL = false;
            stallTimeL = 0;
        }
        if(abs(clawPowerR) > ClosePower) //checking whether motors are stalling
        {
            stallTimeR+=dTime;
            if(stallTimeR>ClawStallTime)//updates stalleR state
            {
                stalledR = true;
            }
        }
        else
        {
            stalledR = false;
            stallTimeR = 0;
        }

        /*-------------------Setting motor power-------------------*/
        if ( !enablePID ) // If PID disbaled
        {
            SetClawL(0);
        }
        else if ( stalledL ) // If stalled, it will run at max stall power
        {
            SetClawL(clawPowerL>0?ClawStallPower:-ClawStallPower);
        }
        else // Setting the powers to the motors.
        {
            SetClawL(clawPowerL);
        }
        if ( !enablePID ) // If PID disbaled
        {
            SetClawR(0);
        }
        else if ( stalledR ) // If stalled, it will run at max stall power
        {
            SetClawR(clawPowerR > 0 ? ClawStallPower : -ClawStallPower);
        }
        else // Setting the powers to the motors
        {
            SetClawR(clawPowerR);
        }

        /*-------------------Logging - final updates-------------------*/
        //logPos++;
        //if (logPos==sizeof(dErrorLLog)/sizeof(dErrorLLog[0]))
        //{
        //    logPos = 0;
        //}
        //dErrorLLog[logPos] = dErrorL;
        //dErrorRLog[logPos] = dErrorR;
        lastErrorL = errorL;
        lastErrorR = errorR;
        lastTime = time1[T1];
        wait1Msec(20);
    }
}


task armTask() // #################################################################################
{
    // Declarations
    int currentTime = 0;
    int lastTime = 0;
    int dTime = 0;
    int error = 0;
    int lastError = 0;
    int dError = 0;
    int accError = 0; // Accumulated error for Integral
    int armTarget = 0;
    int armPower = 0;
    int armPotentiometer = 0;
    int stallTime = 0;
    int armState = 0; // This is the local state (if this isn't there, there is a 1 in 40 chance that the command won't execute)
    // Firing
    int fireTargetTime = 0; // For timeout
    bool fire = false; // Tells the code that the fire macro has been called
    bool stalled = false;
    bool enablePID = false;

    // Average Derrors
    int logPos = 0;
    int dErrorAvg = 0;
    int dErrorLog[] = {0,0,0,0,0,0,0,0,0,0};

    while (true)
    {
        // Updates
        armState = ArmState;
        if (armState != 0) // 0 is the "State is up to date - state. Once the variables are updated in the code, state will go back to 1
        {
            switch (armState) // Sets targets
            {
            case 1: // Custom angle
                armTarget = CustomAngle;
                fire = false;
                enablePID = true;
                break;
            case 2:
                armTarget = ArmDownAngle;
                fire = false;
                enablePID = true;
                break;
            case 3:
                armTarget = ArmPrimeAngle;
                fire = false;
                enablePID = true;
                break;
            case 4:
                armTarget = ArmHighAngle;
                fire = false;
                enablePID = true;
                break;
            case 5:
                armTarget = ArmTopAngle;
                enablePID = true;
                fire = true;
                break;
            default:
                enablePID = false;
                fire = false;
                break;
            }
            stallTime = 0; // Time before stall is true
            stalled = false; // Limits motor power
            //accError = 0; // We don't what to reset this because we don't want it to forget the rubber band correction
            dErrorAvg = 0;
            dErrorLog[0]=dErrorLog[1]=dErrorLog[2]=dErrorLog[3]=dErrorLog[4]=dErrorLog[5]=dErrorLog[6]=dErrorLog[7]=dErrorLog[8]=dErrorLog[9]= 0;
            lastError = armTarget - SensorValue[armPot];
            fireTargetTime = 0;
            ArmState = 0;    // Setting arm state to updated
        }
        currentTime = time1[T1];
        dTime = currentTime - lastTime;
        armPotentiometer = SensorValue[armPot];
        lastTime = currentTime;
        error = armTarget - armPotentiometer;
        dError = (error - lastError)*(dTime>0?1000/dTime:0);

//PID addition part
        if ((abs(accError)>abs(accError+error)) ) // If acc error will be reduced
        {
            accError+= error;
        }
        else if ((abs(error*ArmP + accError*ArmI)+ArmFineOffset)<=ArmPILimit)// If the motor output is less than the cap, you can accumulate
        {
            accError+=error;
        }
        armPower = (abs(error*ArmFineP)<ArmFinePLimit? error*ArmFineP:(error*ArmP+(error>0?ArmFineOffset:-ArmFineOffset))) + dErrorAvg*ArmD + accError*ArmI; //arm power according to the PIDs
//Stall Check
        if(abs(armPower)> ArmStallDetect)// Checking whether motors are stalling
        {
            stallTime+=dTime;
            if(stallTime>ArmStallTime) // Updates stalleL state
            {
                stalled = true;
            }
        }
        else
        {
            stalled = false;
            stallTime = 0;
        }
//Fire stuffs
        if (fire && fireTargetTime == 0)
        {
            fireTargetTime = currentTime+FireExpireTime;
        }
        else if (fire && armPotentiometer >= FireDetectAngle && fireTargetTime > (currentTime+FireOverdriveTime) )
        {
            fireTargetTime = currentTime+FireOverdriveTime;
        }
        /*------------------Data Logging-----------------*/
        //datalogDataGroupStart(); 
        //datalogAddValue(0,motor[lift1]);
        //datalogAddValue(1,dError);
        //datalogAddValue(2,dErrorAvg);
        //datalogDataGroupEnd();
        //Setting motor powers /* 
        if (!enablePID)
        {
            SetArm(0);
        }
        else if (fire)
        {
            SetArm(127);
        }
        else if (stalled) // If stalled, it will run at max stall power
        {
            SetArm(armPower>0?ArmStallPower:-ArmStallPower);
        }
        else // Setting the power to the motors.
        {
            SetArm(armPower);
        }
        if (fire && currentTime > fireTargetTime)
        {
            fire = false;
            ArmFired = true;
            if (ArmState == 0)
            {
                ArmState = 4; //the state at which the arm will go upright
            }
        }
        dErrorAvg+= (-dErrorLog[logPos]/10);
        dErrorLog[logPos] = dError;
        dErrorAvg+= (dError/10);
        ++logPos;
        if (logPos>9)
        {
            logPos = 0;
        }
        lastError = error;
        lastTime = currentTime;
        wait1Msec(20);
    }
}
task driveManager()
{
    while (true)
    {
        if (vexRT[Btn6U])
        {
            ClawState = 2;
        }
        else if (vexRT[Btn6D])
        {
            ClawState =3;
        }
        else if (vexRT[Btn8R])
        {
            ClawState = 9;
        }
        if (vexRT[Btn5U]) // arm testing
        {
            ArmState= 3;
        }
        else if (vexRT[Btn5D])
        {
            ArmState = 2;
        }
        else if (vexRT[Btn7L])
        {
            ArmState = 9;
        }
        else if (vexRT[Btn7D])
        {
            ArmState = 5;
        }

        // This will manage the inputs from the driver and decide what state to put everything on the robot
        wait1Msec(20);
    }
}

/*----------------To do list------------------*/
/*
 * calculate distance to fence so we can go back the exact same distance
 * fix the drive distance functionn
 * fix the parameters in the drive distance function
*/

task autonomous()
{
    clearDebugStream();
    datalogClear();
    clearTimer(T1);
    startTask(clawTask);
    wait1Msec(5);
    startTask(armTask);

    // Claw opening

    ClawState = 5;
    while(!((SensorValue[clawLPot] < (ClawLFullOpen + 100) && SensorValue[clawLPot] > (ClawLFullOpen - 100)) &&
        (SensorValue[clawRPot] < (ClawRFullOpen + 100) && SensorValue[clawRPot] > (ClawRFullOpen - 100)))){} // Wait until state

    ArmState = 1;  // Raise arms up
    while(!(SensorValue[armPot] < (CustomAngle + 100) && SensorValue[armPot] > (CustomAngle - 100))){} // Wait until state

    ArmState = 9;

    ////while(SensorValue[middle] > 400 /*adjust value*/){
    //    SetBase(20,20);

    //    if(SensorValue[middle] < 400)
    //    {
    //        SetBase(0,0);
    //        break;
    //    }
    //}

    wait1Msec(100);
    SensorValue[encoderL] = SensorValue[encoderR] = 0;

    // Move foward
    int firstdrive = 500;
    int encR = 600;

    while(((Sensorvalue[encoderR] + Sensorvalue[encoderL]) /2 )< firstdrive){
        SetBase(70,70);
    }



    //while(Sensorvalue[encoderR] < -400 )
    //    {

    //    }



    wait1Msec(200);
    SensorValue[encoderL] = SensorValue[encoderR] = 0;

    // Turn horizintal
    while(Sensorvalue[encoderR] < 470){
        SetBase(-40,40);

  }

  SensorValue[encoderL] = SensorValue[encoderR] = 0;
  while(((Sensorvalue[encoderR] + Sensorvalue[encoderL])*0.5) < encR){
        SetBase(100,100);
    }

    SensorValue[encoderL] = SensorValue[encoderR] = 0;
    while(Sensorvalue[encoderR] < 470){
        SetBase(-40,40);

  }


        SetBase(-40,-40);

        wait1Msec(1000)

        // Bad very baaaaad
        //SetBase(0,0);


      ArmState = 1;  // Raise arms up
    while( !(SensorValue[armPot] < (CustomAngle + 100) && SensorValue[armPot] > (CustomAngle - 100)) )
    {
        //C: Why is this here?
    }










    //wait1Msec(200);


    ////disable PID
    //wait1Msec(300)
    //SensorValue[encoderL] = SensorValue[encoderR] = 0;

    ////move foward
    //while(sensorvalue[encoderR] < 400)///////{
    //    SetBase(40,40);

 // }

 // wait1Msec(300);

 // SensorValue[encoderL] = SensorValue[encoderR] = 0;
    ////turns backward
    //while(sensorvalue[encoderR] < 100)/////////{
    //    SetBase(-40,40);

 // }

 // wait1Msec(300);
 // //moving towards fence
 // SensorValue[encoderL] = SensorValue[encoderR] = 0;
 // while(sensorvalue[encoderR] < 100)///////{
    //    SetBase(-100,-100);

 // }
 // wait1Msec(300);

 // // stop base
 // SetBase(0,0);




    //SensorValue[encoderL] = SensorValue[encoderR] = 0;
    //while(SensorValue[encoderL] > -720)
    //{
    //    SetBase(-30,0);
    //}

    //SetBase(0,0);        // I set motors to zero after it reaches center of the field

    //wait10Msec(10);

    //SensorValue[encoderL] = SensorValue[encoderR] = 0;
    //while(SensorValue[encoderR] < 120)
    //{
    //    SetBase(60,60);
    //    }

    //wait10Msec(30);


    ////robot closes claw and picks up cubes
    //ClawState = 2;
    //while(!((SensorValue[clawLPot] < (CloseLAngle + 100) && SensorValue[clawLPot] > (CloseLAngle - 100)) &&
    //    (SensorValue[clawRPot] < (CloseRAngle + 100) && SensorValue[clawRPot] > (CloseRAngle - 100)))){} // Wait until state


    ////robot lifts up arm
    //ArmState = 4;
    //while(!(SensorValue[armPot] < (ArmHighAngle + 100) && SensorValue[armPot] > (ArmHighAngle - 100))){} // Wait until state

    //SensorValue[encoderL] = SensorValue[encoderR] = 0;
    //while(SensorValue[encoderL] > -100) {
    //    SetBase(-30,0);
    //}

    //SensorValue[encoderL] = SensorValue[encoderR] = 0;
    //while(SensorValue[encoderL] > -70) {
    //    SetBase(-30,-30);
    //}
    //SetBase(0,0)







    //wait10Msec(500);

    ////robot turn 90 degrees when it gets to line
    //while(SensorValue(front) > 400 &&  SensorValue(centerback) > 400 ){
    //    SetBase(-40,40);
    //    while(SensorValue(front) < 400 && SensorValue(centerback) > 400){
    //        SetBase(-30,30);
    //    }
    //    while(SensorValue(front) > 400 && SensorValue(centerback) < 400){
    //        SetBase(30,-30);
    //    }
    //}

    //SetBase(0,0);

    //wait1Msec(200);



    ////robot moves a distance of half the field


    //driveDistance(600,100);  //sets drive distance to 61 inches and power to 80
    //wait1Msec(200);

    ////robot closes claw and picks up cubes
    //ClawState = 2;
    //while(!((SensorValue[clawLPot] < (CloseLAngle + 100) && SensorValue[clawLPot] > (CloseLAngle - 100)) &&
    //    (SensorValue[clawRPot] < (CloseRAngle + 100) && SensorValue[clawRPot] > (CloseRAngle - 100)))){} // Wait until state


    ////robot lifts up arm
    //ArmState = 4;
    //while(!(SensorValue[armPot] < (ArmHighAngle + 100) && SensorValue[armPot] > (ArmHighAngle - 100))){} // Wait until state


    //SensorValue(encoderR) = SensorValue(encoderL)= 0;

    ////robot does 90 degree turn
    //while(SensorValue(encoderR) > 1000)
    //{
    //    SetBase(-40,40);
    //}
    //SetBase(0,0);

    ////robot moves backwards till it sees the line
    ////Set code to stop robot from bumbing into the fence if it doesnt read the sensors
    //while(SensorValue(rightback) > 400 /*adjust value*/&& SensorValue(leftback) > 400/*adjust value*/){
    //    SetBase(-40,-40);
    //    if(SensorValue(rightback) < 400/*adjust value*/ && SensorValue(leftback) > 400/*adjust value*/)
    //    {  while(SensorValue(leftback) > 400){
    //            SetBase(-30,0);
    //        }
    //    }
    //    if(SensorValue(rightback) > 400/*adjust value*/ && SensorValue(leftback) < 400/*adjust value*/)
    //    {  while(SensorValue(rightback) > 400){
    //            SetBase(0,-30);
    //        }
    //    }
    //}

    //SetBase(0,0);    //zeroing motors
    //wait1Msec(100);

    ////robot moves cloesr to the fence
    //while(SensorValue(middle) > 400/*adjust value*/)
    //{
    //    SetBase(-35,-35);
    //}
    //SetBase(0,0);

    ////fire cube
    //ArmState = 5;  //sets arm to fire
    //while(!(SensorValue[armPot] < (ArmTopAngle + 100) && SensorValue[armPot] > (ArmTopAngle - 100))){} // Wait until state

    ////Releases Cube
    //ClawState = 5;
    //while(!((SensorValue[clawLPot] < (ClawLFullOpen + 100) && SensorValue[clawLPot] > (ClawLFullOpen - 100)) &&
    //    (SensorValue[clawRPot] < (ClawRFullOpen + 100) && SensorValue[clawRPot] > (ClawRFullOpen - 100)))){} // Wait until state

    ////brings lift back down
    //ArmState = 2;  //atate brings arm down
    //while(!(SensorValue[armPot] < (ArmDownAngle + 100) && SensorValue[armPot] > (ArmDownAngle - 100))){} // Wait until state

    ////it should back up a little bit
    //int targetL;   // find wht target value we should use
    //while(SensorValue[encoderL] <  targetL)
    //{
    //    SetBase(50,50);

    //}

    ////drives back to pik stars
    //while(SensorValue[centerback] > 400)
    //{
    //    SetBase(50,50);
    //}

    //wait1Msec(100);

    ////claw closing
    //ClawState = 2;
    //while(!((SensorValue[clawLPot] < (CloseLAngle + 100) && SensorValue[clawLPot] > (CloseLAngle - 100)) &&
    //    (SensorValue[clawRPot] < (CloseRAngle + 100) && SensorValue[clawRPot] > (CloseRAngle - 100)))){} // Wait until state
    ////arm raising
    //ArmState = 4;
    //while(!(SensorValue[armPot] < (ArmHighAngle + 100) && SensorValue[armPot] > (ArmHighAngle - 100))){} // Wait until state

    ////drive up to line again
    //while(SensorValue(rightback) > 400 /*adjust value*/&& SensorValue(leftback) > 400/*adjust value*/){
    //    SetBase(-40,-40);

    //    if(SensorValue(rightback) < 400/*adjust value*/ && SensorValue(leftback) > 400/*adjust value*/)
    //    {  while(SensorValue(leftback) > 400){
    //            SetBase(-30,0);
    //        }
    //    }
    //    if(SensorValue(rightback) > 400/*adjust value*/ && SensorValue(leftback) < 400/*adjust value*/)
    //    {  while(SensorValue(rightback) > 400){
    //            SetBase(0,-30);
    //        }
    //    }
    //}

    //while(SensorValue(leftback) > 400/*adjust value*/)
    //{
    //    SetBase(-35,-35);
    //}
    //SetBase(0,0);

    ////firing stars
    //ArmState = 5;
    //while(!(SensorValue[armPot] < (ArmTopAngle + 100) && SensorValue[armPot] > (ArmTopAngle - 100))){} // Wait until state

    //// Releases Stars
    //ClawState = 5;
    //while(!((SensorValue[clawLPot] < (ClawLFullOpen + 100) && SensorValue[clawLPot] > (ClawLFullOpen - 100)) &&
    //    (SensorValue[clawRPot] < (ClawRFullOpen + 100) && SensorValue[clawRPot] > (ClawRFullOpen - 100)))){} // Wait until state

    ////Lowers Arm
    //ArmState = 2;
    //while(!(SensorValue[armPot] < (ArmDownAngle + 100) && SensorValue[armPot] > (ArmDownAngle - 100))){}//brings claw down

    ////for now end autonomous;
}

/*** What appears to be the original code
task autonomous()
{
  //open claw

    motor[clawL]=motor[clawR]= 100;
    wait1Msec(200);
    motor[clawL]=motor[clawR]=0;



    //drive forward until line
    if(SensorValue[middle]<100){

        motor[baseR1]=motor[baseR2]= 127;
        motor[baseL1]=motor[baseL2]= 127;
        //motor[left1]=motor[left2]=motor[left3]= 127;
        //motor[right1]=motor[right2]=motor[right3]= 127;
    }

    else{

        motor[baseR1]=motor[baseR2]= 0;
        motor[baseL1]=motor[baseL2]= 0;
        //motor[left1]=motor[left2]=motor[left3]= 0;
        //motor[right1]=motor[right2]=motor[right3]= 0;
    }

    //zero encoders
    nMotorEncoder(left)=nMotorEncoder(right)=0;

    //turn until front and centerback light sensors are aligned
    if(SensorValue[centerback] && SensorValue[front] < 100){

        motor[baseR1]=motor[baseR2]= -100;
        motor[baseR1]=motor[baseR2]= 100;

        //motor[left1]=motor[left2]=motor[left3]= -100;
        //motor[right1]=motor[right2]=motor[right3]= 100;
    }

    else{

        motor[baseR1]=motor[baseR2]= 0;
        motor[baseR1]=motor[baseR2]= 0;

        //motor[left1]=motor[left2]=motor[left3]= 0;
        //motor[right1]=motor[right2]=motor[right3]= 0;
    }

    turndist = (SensorValue(left)+SensorValue(right))/2;

    //drive towards cube
    motor[baseR1]=motor[baseR2]= 127;
    motor[baseL1]=motor[baseL2]= 127;
    wait1Msec(200);
    motor[baseR1]=motor[baseR2]= 0;
    motor[baseL1]=motor[baseL2]= 0;

    //close claw
    motor[claw1]=motor[claw1]= -100;
    wait1Msec(200);
    motor[claw1]=motor[claw1]=0;

    // Lift Claw
    wait1Msec(100);
    int sensorPot;

    //setting pot value to 0
    SensorValue[armPot] = 0;
    senorPot = SensorValue[armPot];

    //claw lifts until arm is high enough that it doesn't hit stars when it turns
    while( sensorPot < 2000){
      motor[lift1] = 100;
      motor[lift2] = 100;
      motor[lift3] = 100;
      motor[lift4] = 100;
      sensorPot = SensorValue[armPot];
    }

     motor[lift1] =  motor[lift2]=  motor[lift3] = motor[lift4] = 0;



    //turn 90 degrees so rear faces wall
    while (nMotorEncoder[left] < turndist)
    {
         motor[baseR1]=motor[baseR2]= -100;
        motor[baseR1]=motor[baseR2]= 100;
    }
        motor[baseR1]=motor[baseR2]= 0;
        motor[baseR1]=motor[baseR2]= 0;

    //drive backwards until line
    if(SensorValue[centerback] && SensorValue[leftback] && SensorValue[rightback] <100){
        motor[baseR1]=motor[baseR2]= -127;
    motor[baseL1]=motor[baseL2]= -127;
    }else{
        motor[baseR1]=motor[baseR2]= 0;
        motor[baseR1]=motor[baseR2]= 0;
    }

    // Throw Cube

    // Lower arm

    // Open claw to grab stars

    // Close Claw

    // Go back to fence

    // Throw over fence
}
***/

task usercontrol()
{
    clearDebugStream();
    datalogClear();
    clearTimer(T1);
    startTask(clawTask);
    startTask(driveManager);
    wait1Msec(5);
    startTask(armTask);
    int leftPower = 0;
    int rightPower = 0;
    while (true)
    {
/***
        if(vexRT(Btn8D))
        {
            autonomous1();
    }
***/
        leftPower     = vexRT[Ch3] + vexRT[Ch1];
        rightPower     = vexRT[Ch3] - vexRT[Ch1];
        SetBase(leftPower,rightPower);
        wait1Msec(20);
    }
}
