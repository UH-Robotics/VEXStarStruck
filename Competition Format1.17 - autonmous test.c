/* Comment for Demonstrative Purposes*/
#pragma config(Sensor, in1,    clawLPot,       sensorPotentiometer)
#pragma config(Sensor, in2,    clawRPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl9,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encoderL,       sensorQuadEncoder)
#pragma config(Motor,  port1,           clawR,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift4,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           baseR1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           baseR2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           baseL1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           baseL2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawL,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//Predeclarations
task clawTask();
void SetBase(int powerL, int powerR);
void SetArm(int power);

// Pot calibration

//Variables
	//Claw variables
int ClawLCalibrate = 0; //97 - calibrated value. difference from full closed value: (touching motor)
int ClawRCalibrate = 0; //4060 - calibrated value. difference form full closed value: + means bigger number
int ClawState = 9; 						// 0 - open, 1 - semi-closed, 2 - closed
int CloseLAngle = 820+ClawLCalibrate; 				//the angle the claw is closed
int CloseRAngle = 3100+ClawRCalibrate; 				//the angle the claw is closed
int ClawLSemicloseAngle = 1900+ClawLCalibrate;//the angle the claw stays at in intake pos
int ClawRSemicloseAngle = 2120+ClawRCalibrate;
int ClawLOpen = 1900+ClawLCalibrate; 					//Angle claw is fully open
int ClawROpen = 1600+ClawRCalibrate;
int ClawLFullOpen = 1900+ClawLCalibrate; 			//If we get Stuck, we can fully open the claw
int ClawRFullOpen = 1600+ClawRCalibrate;
int CustomAngleL = 0+ClawLCalibrate; //If we want different/custom angles
int CustomAngleR = 0+ClawRCalibrate;

		//PID/stalls
int ClosePower = 70;//127 				// the test value for stall detect
int ClawStallPower = 70;//60 			//power after stall
int ClawStallTime = 1500;//1000 			//if the claw is not moving for this time, go to low power
float ClawP = .2;//.1? 	//P value for claw PID
float ClawD = .001;//.001 	// D value for PID
float ClawI = .005; //.015
float ClawFineP = .4;//.2 //when error gets close to 0, this takes over
int 	ClawFinePLimit = 10; //15 // this is the max power Fine motor can provide
float ClawFineOffset = (ClawFineP==0?0:ClawFinePLimit-(ClawFinePLimit/ClawFineP*ClawP));
int 	PILimit = 65;//60 // the limit of the total power P+I can provide

	//Arm Variables##############################################################
int ArmState = 9; 		// disabled
int ArmCalibrate = 0; //2810 is zero position
float ArmP = .8;		//.1? 	//P value for claw PID
float ArmD = .002;	//.006 	// D value for PID
float ArmI = .0025; 	//.0025
float ArmFineP = .2;	//.08 //when error gets close to 0, this takes over
int ArmFinePLimit = 8; //12 // this is the max power Fine motor can provide
float ArmFineOffset = (ArmFineP==0?0:ArmFinePLimit-(ArmFinePLimit/ArmFineP*ArmP));
int ArmPILimit = 45;	//60 // the limit of the total power P+I can provide
int ArmStallPower = 50; //60
int ArmStallDetect = 50;//60
int ArmStallTime = 1000;//1000 in milliseconds
int FireDetectAngle = 2800+ArmCalibrate; //2880 the angle it will consider the
int FireExpireTime = 1500; //1500 if it is firing for longer than this amount of time, firing stops
int FireOverdriveTime = 20; // 60number of milliseconds it will keep driving arm after it reached fire angle
bool ArmFired = false;
// arm angles
int CustomAngle 	= 1400; 	//Custom arm angle
int ArmDownAngle	= 960+ArmCalibrate;//intake angle
int ArmPrimeAngle = 1400+ArmCalibrate; //1070 just above the ground
int ArmHighAngle 	= 1690+ArmCalibrate;//just a fun angle for w/e
int ArmTopAngle 	= 2940+ArmCalibrate;//after firing it will go here

//functions
void pre_auton()
{
  bStopTasksBetweenModes = true;
}
void SetBase(int powerL, int powerR)
{
		motor[baseL1]=powerL;
		motor[baseL2]=powerL;
		motor[baseR1]=powerR;
		motor[baseR2]=powerR;
		return;
}
void SetArm(int power)
{
	  motor[lift1]=power;
	  motor[lift2]=power;
	  motor[lift3]=power;
	  motor[lift4]=power;
}
void SetClawL(int powerL)
{
	motor[clawL] = powerL;
}
void SetClawR(int powerR)
{
	motor[clawR] = powerR;
}

//tasks
task clawTask() //this just manages the PID on the robot
{
	int clawLTarget = 0;
	int clawRTarget = 0;
	int clawPowerL = 0;
	int clawPowerR = 0;
	int potentiometerL = 0;
	int potentiometerR = 0;
	int currentTime = time1[T1];
	int lastTime = currentTime;
	int dTime = 0;
	int errorL = 0;
	int errorR = 0;
	int lastErrorL = 0;
	int lastErrorR = 0;
	int dErrorL = 0;
	int dErrorR = 0;
	int dErrorLLog[] = {0,0,0,0};
	int dErrorRLog[] = {0,0,0,0};
	//int avgDErrorL = 0;
	//int avgDErrorR = 0;
	//int logPos = 0;
	int accErrorL = 0;//accumulated error for Integral
	int accErrorR = 0;
	bool enablePID = false;

	//stall timing
	bool stalledL = false;
	bool stalledR = false;
	int stallTimeL = 0;
	int stallTimeR = 0;

	while (true)
	{
		//updates values
		potentiometerL = SensorValue[clawLPot];
		potentiometerR = SensorValue[clawRPot];
		currentTime = time1[T1];
		dTime = currentTime - lastTime;

		errorL = -clawLTarget + potentiometerL; //Updating errors (difference between target and true pos, negative is more open)
		errorR = +clawRTarget - potentiometerR;
		//first run in this state? do this!
		if (ClawState != 0) //this really doesn't mean much. only for the first state change where dError would be big otherwise
		{
			switch (ClawState) //sets targets
			{
				case 1:
					clawLTarget = CustomAngleL;
					clawRTarget = CustomAngleR;
					enablePID = true;
					break;
				case 2:
					clawLTarget = CloseLAngle;
					clawRTarget = CloseRAngle;
					enablePID = true;
					break;
				case 3:
					clawLTarget = ClawLSemicloseAngle;
					clawRTarget = ClawRSemicloseAngle;
					enablePID = true;
					break;
				case 4:
					clawLTarget = ClawLOpen;
					clawRTarget = ClawROpen;
					enablePID = true;
					break;
				case 5:
					clawLTarget = ClawLFullOpen;
					clawRTarget = ClawRFullOpen;
					enablePID = true;
					break;
				default:
					enablePID = false;
					break;
			}
			ClawState = 0;
			lastErrorL = errorL;
			lastErrorR = errorR;
			accErrorL = accErrorR = 0;//setting integral to 0
			stalledL = false;
			stalledR = false;
			stallTimeL = 0;
			stallTimeR = 0;
		}

		// dError calculation
		dErrorL = (errorL - lastErrorL)*(dTime>0?1000/dTime:0); //the speed over the last time period in pot ticks per sec
		dErrorR = (errorR - lastErrorR)*(dTime>0?1000/dTime:0);
		//dErrorLLog[logPos] = dErrorL; // trying to filter bad values
		//dErrorRLog[logPos] = dErrorR;
		//avgDErrorL = dErrorLLog[0];
		//avgDErrorR = dErrorRLog[0];
		//for (int x = 1; x<(sizeof(dErrorLLog)/sizeof(dErrorLLog[0])); ++x)// finding the minimum dError
		//{
		//	avgDErrorL += dErrorLLog[x]; //= (abs(avgDErrorL)<abs(dErrorLLog[x]))?avgDErrorL:dErrorLLog[x];	//min dErrorL value
		//	avgDErrorR += dErrorRLog[x]//= (abs(avgDErrorR)<abs(dErrorRLog[x]))?avgDErrorR:dErrorRLog[x];; //min R value
		//}
		//avgDErrorL = avgDErrorL/(sizeof(dErrorLLog)/sizeof(dErrorLLog[0]));
		//avgDErrorR = avgDErrorR/(sizeof(dErrorLLog)/sizeof(dErrorLLog[0]));

		//Integral addition
		if ((abs(accErrorL)>abs(accErrorL+errorL))) //if acc error will be reduced
		{
			accErrorL+= errorL;
		}
		else if ((abs(errorL*ClawP + accErrorL*ClawI)+ClawFineOffset)<=PILimit)//if the motor output is less than the cap, you can accumulate)
		{
			accErrorL+=errorL;
		}
		if ((abs(accErrorR)>abs(accErrorR+errorR))  ) //if acc error will be reduced
		{
			accErrorR+= errorR;
		}
		else if ((abs(errorR*ClawP + accErrorR*ClawI)+ClawFineOffset)<=PILimit)//if the motor output is less than the cap, you can accumulate)
		{
			accErrorR+=errorR;
		}
		clawPowerL = (abs(errorL*ClawFineP)<ClawFinePLimit? errorL*ClawFineP:(errorL*ClawP+(errorL>0?ClawFineOffset:-ClawFineOffset))) + dErrorL*ClawD + accErrorL*ClawI; //claw power according to the PIDs
		clawPowerR = (abs(errorR*ClawFineP)<ClawFinePLimit? errorR*ClawFineP:(errorR*ClawP+(errorR>0?ClawFineOffset:-ClawFineOffset))) + dErrorR*ClawD + accErrorR*ClawI; // attempt to filter stuff
		//----------------------------logging
		//writeDebugStreamLine("Claw Power L: %d\nClaw Power R: %d",clawPowerL,clawPowerR);
		//datalogDataGroupStart();
		//datalogAddValue(0,motor[clawL]);
		//datalogAddValue(1,motor[clawR]);
		//datalogAddValue(2,errorL);
		//datalogAddValue(3,errorR);
		//datalogDataGroupEnd();
		//Stall stuff------------------------------
		if(abs(clawPowerL)> ClosePower)//checking whether motors are stalling
		{
			stallTimeL+=dTime;
			if(stallTimeL>ClawStallTime) //updates stalleL state
			{
				stalledL = true;
			}
		}
		else
		{
			stalledL = false;
			stallTimeL = 0;
		}
		if(abs(clawPowerR) > ClosePower) //checking whether motors are stalling
		{
			stallTimeR+=dTime;
			if(stallTimeR>ClawStallTime)//updates stalleR state
			{
				stalledR = true;
			}
		}
		else
		{
			stalledR = false;
			stallTimeR = 0;
		}

//Setting motor power ------------------------------------------------
		if(!enablePID)//If PID disbaled
		{
			SetClawL(0);
		}
		else if(stalledL)//If stalled, it will run at max stall power
		{
			SetClawL(clawPowerL>0?ClawStallPower:-ClawStallPower);
		}
		else// Setting the powers to the motors.
		{
			SetClawL(clawPowerL);
		}
		if(!enablePID)//If PID disbaled
		{
			SetClawR(0);
		}
		else if(stalledR)//If stalled, it will run at max stall power
		{
			SetClawR(clawPowerR>0?ClawStallPower:-ClawStallPower);
		}
		else// Setting the powers to the motors.
		{
			SetClawR(clawPowerR);
		}

		//final updates
		//logPos++;
		//if (logPos==sizeof(dErrorLLog)/sizeof(dErrorLLog[0]))
		//{
		//	logPos = 0;
		//}
		//dErrorLLog[logPos] = dErrorL;
		//dErrorRLog[logPos] = dErrorR;
		lastErrorL = errorL;
		lastErrorR = errorR;
		lastTime = time1[T1];
		wait1Msec(20);
	}
}
task armTask()//#################################################################################
{
	//declarations
	int currentTime = 0;
	int lastTime = 0;
	int dTime = 0;
	int error = 0;
	int lastError = 0;
	int dError = 0;
	int accError = 0;//accumulated error for Integral
	int armTarget = 0;
	int armPower = 0;
	int armPotentiometer = 0;
	int stallTime = 0;
	int armState = 0; //this is the local state (if this isn't there, there is a 1 in 40 chance that the command won't execute)
	//firing
	int fireTargetTime = 0; // for timeout
	bool fire = false; // tells the code that the fire macro has been called
	bool stalled = false;
	bool enablePID = false;

	//average Derrors
	int logPos = 0;
	int dErrorAvg = 0;
	int dErrorLog[] = {0,0,0,0,0,0,0,0,0,0};

	while (true)
	{
		//Updates
		armState = ArmState;
		if (armState != 0) // 0 is the "State is up to date - state. Once the variables are updated in the code, state will go back to 1
		{
			switch (armState) //sets targets
			{
				case 1: //custom angle
					armTarget = CustomAngle;
					fire = false;
					enablePID = true;
					break;
				case 2:
					armTarget = ArmDownAngle;
					fire = false;
					enablePID = true;
					break;
				case 3:
					armTarget = ArmPrimeAngle;
					fire = false;
					enablePID = true;
					break;
				case 4:
					armTarget = ArmHighAngle;
					fire = false;
					enablePID = true;
					break;
				case 5:
					armTarget = ArmTopAngle;
					enablePID = true;
					fire = true;
					break;
				default:
					enablePID = false;
					fire = false;
					break;
			}
			stallTime = 0; //time before stall is true
			stalled = false; //limits motor power
			//accError = 0; // we don't what to reset this because we don't want it to forget the rubber band correction
			dErrorAvg = 0;
			dErrorLog[0]=dErrorLog[1]=dErrorLog[2]=dErrorLog[3]=dErrorLog[4]=dErrorLog[5]=dErrorLog[6]=dErrorLog[7]=dErrorLog[8]=dErrorLog[9]= 0;
			lastError = armTarget - SensorValue[armPot];
			fireTargetTime = 0;
			ArmState = 0;	// Setting arm state to updated
		}
		currentTime = time1[T1];
		dTime = currentTime - lastTime;
		armPotentiometer = SensorValue[armPot];
		lastTime = currentTime;
		error = armTarget - armPotentiometer;
		dError = (error - lastError)*(dTime>0?1000/dTime:0);

//PID addition part
		if ((abs(accError)>abs(accError+error)) ) //if acc error will be reduced
		{
			accError+= error;
		}
		else if ((abs(error*ArmP + accError*ArmI)+ArmFineOffset)<=ArmPILimit)//if the motor output is less than the cap, you can accumulate
		{
			accError+=error;
		}
		armPower = (abs(error*ArmFineP)<ArmFinePLimit? error*ArmFineP:(error*ArmP+(error>0?ArmFineOffset:-ArmFineOffset))) + dErrorAvg*ArmD + accError*ArmI; //arm power according to the PIDs
//Stall Check
		if(abs(armPower)> ArmStallDetect)//checking whether motors are stalling
		{
			stallTime+=dTime;
			if(stallTime>ArmStallTime) //updates stalleL state
			{
				stalled = true;
			}
		}
		else
		{
			stalled = false;
			stallTime = 0;
		}
//Fire stuffs
		if (fire && fireTargetTime == 0)
		{
			fireTargetTime = currentTime+FireExpireTime;
		}
		else if (fire && armPotentiometer >= FireDetectAngle && fireTargetTime > (currentTime+FireOverdriveTime) )
		{
			fireTargetTime = currentTime+FireOverdriveTime;
		}
		//datalogDataGroupStart(); ------------------  datalogging
		//datalogAddValue(0,motor[lift1]);
		//datalogAddValue(1,dError);
		//datalogAddValue(2,dErrorAvg);
		//datalogDataGroupEnd();
		//Setting motor powers
		if (!enablePID)
		{
			SetArm(0);
		}
		else if(fire)
		{
			SetArm(127);
		}
		else if(stalled)//If stalled, it will run at max stall power
		{
			SetArm(armPower>0?ArmStallPower:-ArmStallPower);
		}
		else// Setting the power to the motors.
		{
			SetArm(armPower);
		}
		if (fire && currentTime>fireTargetTime)
		{
			fire = false;
			ArmFired = true;
			if (ArmState == 0)
			{
				ArmState = 4; //the state at which the arm will go upright
			}
		}
		dErrorAvg+= (-dErrorLog[logPos]/10);
		dErrorLog[logPos] = dError;
		dErrorAvg+= (dError/10);
		++logPos;
		if (logPos>9)
		{
			logPos = 0;
		}
		lastError = error;
		lastTime = currentTime;
		wait1Msec(20);
	}
}
task driveManager()
{
	while (true)
	{
		if (vexRT[Btn6U])
		{
			ClawState = 2;
		}
		else if (vexRT[Btn6D])
		{
			ClawState =3;
		}
		else if (vexRT[Btn8R])
		{
			ClawState = 9;
		}
		if (vexRT[Btn5U]) // arm testing
		{
			ArmState= 3;
		}
		else if (vexRT[Btn5D])
		{
			ArmState = 2;
		}
		else if (vexRT[Btn7L])
		{
			ArmState = 9;
		}
		else if (vexRT[Btn7D])
		{
			ArmState = 5;
		}

		//this will manage the inputs from the driver and decide what state to put everything on the robot
		wait1Msec(20);
	}
}

task autonomous()
{
  clearDebugStream();
	datalogClear();
	clearTimer(T1);
	startTask(clawTask);
	wait1Msec(5);
	startTask(armTask);
	int leftPower = 0;
	int rightPower = 0;

	ClawState = 3;
}

task usercontrol()
{
	clearDebugStream();
	datalogClear();
	clearTimer(T1);
	startTask(clawTask);
	startTask(driveManager);
	wait1Msec(5);
	startTask(armTask);
	int leftPower = 0;
	int rightPower = 0;
	while (true)
	{
		leftPower 	= vexRT[Ch3] + vexRT[Ch1];
		rightPower 	= vexRT[Ch3] - vexRT[Ch1];
		SetBase(leftPower,rightPower);
		wait1Msec(20);
	}
}
